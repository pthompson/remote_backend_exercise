# RemoteBackendExercise

This application implements a JSON API web server to satisfy the requirements of Remote.com's
backend code exercise take home. The requirements are as follows:

- `mix ecto.setup` will create a `Users` table with 4 columns, id, points and the usual 2 timestamps.
    - `id` is autogenerated so no worries
    - `points` an integer that accepts any number between 0 and 100
    - `timestamps` autogenerated by ecto
    - This should generate 1,000,000 user seeds, each with 0 points.
- The app should start when you run without warnings (warnings in dependencies are okay) or errors using: `mix phx.server`
- When the app starts, a `genserver` should be launched which will:
    - Have 2 elements as state:
        - A random number (let's call it the `min_number`), [0 - 100]
        - A timestamp (which indicates the last time someone queried the genserver, defaults to `nil` for the first query)
    - Run every minute and when it runs:
        - Should update every user's points in the database (using a random number generator [0-100] for each)
        - Refresh the `min_number` of the genserver state with a new random number
    - Should accept a `handle_call` that:
        - Queries the database for all users with more points than `min_number` but only retrieve a max of 2 users.
        - Updates the genserver state `timestamp` with the current timestamp
        - Returns the users just retrieved from the database, as well as the timestamp of the **previous `handle_call`**

- Build a single endpoint, root `/`:
    - This can be handled by an action which will call the previously mentioned `genserver` and return the result.

## Reflection

I found the exercise to be pretty straightforward. The challenge was in testing an application where the results are randomly generated and updated on a regular interval. I dealt with this by:

* Seeding the database with known data for testing, so that at least the first call would return predictable results.
* Testing the GenServer by calling the callbacks directly, so that I could control the flow. This is not black box testing, but my thinking was that it was a reasonable tradeoff and the least complex option. Another way would have been to create a pure functional core that the GenServer could depend on and that could be independently tested, but since a large part of the implementation depends on side effects (database interactions), the functional core would have been quite thin.
* In testing random data, I simply made sure that the data was valid and changed from the prior call, however this introduces the possibility that the generated random data would be the same between calls, resulting in invalid test failures. I addressed this by adding documentation to the tests where this might happen. Not the best, but it kept things simple for this exercise.

To start the Phoenix server:

  * Install dependencies with `mix deps.get`
  * Create and migrate your database with `mix ecto.setup`
  * Start Phoenix endpoint with `mix phx.server` or inside IEx with `iex -S mix phx.server`

Now you can visit [`localhost:4000`](http://localhost:4000) from your browser.
